//! Code Generation - Rust Backend

use crate::parser::{AST, App, AppMember, Function, Statement, Expr};

pub fn generate_rust(ast: &AST) -> String {
    let mut output = String::new();
    
    // Generate header
    output.push_str("// Generated by AetherScript Compiler v1.0\n");
    output.push_str("#![no_std]\n");
    output.push_str("#![no_main]\n\n");
    
    // Generate each app
    for app in &ast.apps {
        output.push_str(&generate_app(app));
    }
    
    output
}

fn generate_app(app: &App) -> String {
    let mut output = String::new();
    
    output.push_str(&format!("// App: {}\n", app.name));
    
    // Generate annotations as comments
    for ann in &app.annotations {
        output.push_str(&format!("// @{}\n", ann.name));
    }
    
    output.push_str("\n");
    
    // Generate members
    for member in &app.members {
        match member {
            AppMember::Function(func) => {
                output.push_str(&generate_function(func));
            }
            AppMember::Variable(var) => {
                output.push_str(&format!("static {}: {};\n", var.name, var.type_name));
            }
        }
    }
    
    output
}

fn generate_function(func: &Function) -> String {
    let mut output = String::new();
    
    // Generate annotations as attributes
    for ann in &func.annotations {
        if ann.name == "memory" {
            output.push_str("// Memory budget applied\n");
        }
    }
    
    // Function signature
    if func.name == "main" {
        output.push_str("#[no_mangle]\n");
        output.push_str("pub extern \"C\" fn kernel_main() -> ! {\n");
    } else {
        output.push_str(&format!("fn {}(", func.name));
        
        // Parameters
        for (i, param) in func.params.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&format!("{}: {}", param.name, param.type_name));
        }
        
        output.push_str(")");
        
        // Return type
        if let Some(ret) = &func.return_type {
            output.push_str(&format!(" -> {}", ret));
        }
        
        output.push_str(" {\n");
    }
    
    // Function body
    for stmt in &func.body.statements {
        output.push_str(&generate_statement(stmt, 1));
    }
    
    // Close function
    if func.name == "main" {
        output.push_str("    loop {}\n");
    }
    output.push_str("}\n\n");
    
    output
}

fn generate_statement(stmt: &Statement, indent: usize) -> String {
    let indent_str = "    ".repeat(indent);
    
    match stmt {
        Statement::Let { name, value } => {
            format!("{}let {} = {};\n", indent_str, name, generate_expr(value))
        }
        Statement::Assign { name, value } => {
            format!("{}{} = {};\n", indent_str, name, generate_expr(value))
        }
        Statement::Return { value } => {
            if let Some(v) = value {
                format!("{}return {};\n", indent_str, generate_expr(v))
            } else {
                format!("{}return;\n", indent_str)
            }
        }
        Statement::Expr(expr) => {
            format!("{}{};\n", indent_str, generate_expr(expr))
        }
    }
}

fn generate_expr(expr: &Expr) -> String {
    match expr {
        Expr::Number(n) => n.to_string(),
        Expr::String(s) => format!("\"{}\"", s),
        Expr::Ident(i) => i.clone(),
        Expr::Call { name, args } => {
            let args_str = args.iter()
                .map(|a| generate_expr(a))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{}({})", name, args_str)
        }
        Expr::BinOp { op, left, right } => {
            format!("({} {} {})", generate_expr(left), op, generate_expr(right))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::*;

    #[test]
    fn test_generate_simple_function() {
        let ast = AST {
            apps: vec![App {
                name: "Test".to_string(),
                annotations: vec![],
                members: vec![AppMember::Function(Function {
                    name: "main".to_string(),
                    annotations: vec![],
                    is_distributed: false,
                    params: vec![],
                    return_type: None,
                    body: Block {
                        statements: vec![
                            Statement::Return { value: Some(Expr::Number(0.0)) }
                        ],
                    },
                })],
            }],
        };
        
        let code = generate_rust(&ast);
        assert!(code.contains("kernel_main"));
        assert!(code.contains("return 0"));
    }
}
